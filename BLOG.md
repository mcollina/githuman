# Building GitHuman: An AI-Coded Tool for Reviewing AI Code

*How Claude Code built a complete application in 12 days, with a human reviewing every commit*

## The Irony

There's something beautifully recursive about GitHuman's creation story: it's a tool designed to help humans review AI-generated code, and it was itself entirely written by AI—specifically, [Claude Code](https://claude.ai/code).

Every line of code, every test, every CSS rule was generated by Claude. But here's the crucial part: every commit was reviewed by a human before being accepted. GitHuman was built using the exact workflow it was designed to enable.

## The Problem That Sparked It

The traditional code review workflow was designed for human-to-human collaboration. You write code, push a branch, open a PR, and colleagues review it. This works because humans write code incrementally, and by the time something reaches a PR, it's usually been thoughtfully constructed.

AI coding agents don't work this way. They can generate hundreds of lines of code in seconds. By the time you've pushed to a branch and opened a PR, you've already committed (literally) to an approach. The review happens too late to influence the direction.

The insight was simple: **move the review checkpoint to the staging area**. Before `git commit`, not after `git push`.

## The 633-Line Plan

On December 30, 2025, the first commit landed: a 633-line implementation plan. This wasn't code—it was a detailed architectural blueprint covering:

- Technology choices (Fastify, React, SQLite, Shiki)
- API design with OpenAPI schemas
- Database schema and migrations
- CLI command structure
- Frontend component hierarchy
- Testing strategy across three layers

This plan became the north star. Claude would reference it throughout development, and I would update it as requirements evolved.

## Development in Phases

The project was built systematically across 10 phases over 12 days:

### Phase 1-2: Foundation and Git Integration
The first working code established the Fastify server, SQLite database with migrations, and the git diff parsing engine. Node.js 24's native SQLite support (`node:sqlite`) was a key choice—no native dependencies, synchronous API, perfect for a local tool.

### Phase 3-4: Reviews and React Frontend
The core review management API and React SPA came together. The frontend was designed to feel familiar to anyone who's used GitHub's PR interface—file sidebar, unified diff view, syntax highlighting.

### Phase 5-6: Comments and Export
The ability to add inline comments with code suggestions, plus markdown export for documentation. This is where GitHuman started feeling like a real review tool rather than just a diff viewer.

### Phase 7-8: Polish and Mobile
Responsive design became a priority. The interface needed to work on phones and tablets—because sometimes you want to review code away from your desk. Drawers go full-screen on mobile, touch targets are appropriately sized, and the diff view adapts to narrow screens.

### Phase 9: Streamlined Workflow
Branch comparison reviews were added, allowing you to review changes between any two branches, not just staged changes. The landing page was redesigned to prioritize the most common workflow.

### Phase 10: Todo Tracking
A todo list feature was added for tracking follow-up work during reviews. It integrates with the CLI (`githuman todo add "fix this"`) and updates in real-time via Server-Sent Events.

## The Dogfooding Loop

From Phase 4 onwards, GitHuman was used to review its own development. The workflow looked like this:

1. I'd describe a feature or bug to Claude Code
2. Claude would write the implementation
3. The changes would be staged
4. I'd run `githuman serve` and review the diff
5. I'd add comments for issues I spotted
6. Claude would address the feedback
7. Once approved, I'd commit

Here's the twist: **all of this happened from my phone**. I SSH'd into a VPS running Claude Code, with GitHuman's web interface exposed via [Tailscale](https://tailscale.com). Every instruction to Claude, every code review, every approval—done from a mobile browser while away from my desk.

This wasn't just convenient; it validated a core design goal. If you can build an entire application by reviewing AI-generated code on a phone, the mobile experience works.

This tight loop caught real bugs. For example, during the image diff feature, the E2E test passed but images weren't rendering in the browser. The review interface made it easy to spot that `simple-git`'s string handling was corrupting binary data—a fix that came from actually using the tool.

## By the Numbers

- **83 commits** over 12 days
- **100% AI-generated code** with human review
- **175+ tests** (server, CLI, web, E2E)
- **Zero dependencies on cloud services**—everything runs locally

## Key Technical Decisions

**Node.js 24+ requirement**: Using native SQLite and native TypeScript execution (type stripping) meant no build step for development and fewer dependencies.

**Fastify with TypeBox**: Full type safety from API schemas through to frontend consumption, with automatic OpenAPI documentation.

**Shiki for syntax highlighting**: The same engine VS Code uses, running server-side for consistent highlighting across all languages.

**Server-Sent Events**: Real-time updates without WebSocket complexity. When you mark a todo as done from the CLI, the web UI updates instantly.

## What Claude Couldn't Do

While Claude wrote all the code, certain decisions required human judgment:

- **Product direction**: What features matter? What's the core use case?
- **Naming**: "GitHuman" came from brainstorming about the human checkpoint in AI workflows
- **Design aesthetics**: The dark theme, gradient accents, logo design
- **Prioritization**: Which bugs to fix first, which features to defer

The AI was an incredibly capable implementer, but the vision and taste had to come from a human.

## The Meta Lesson

GitHuman exists because AI coding agents are becoming mainstream. Cursor, Copilot, Claude Code—they're changing how software gets written. But "AI wrote it" isn't the same as "it's correct."

The traditional PR review process assumes humans are the authors and reviewers have context on the changes. Neither assumption holds when AI generates hundreds of lines in seconds.

GitHuman is a bet on a different workflow: review before commit, not after push. Give humans a proper interface—not a wall of terminal diff output—to understand and approve AI-generated changes before they become part of the codebase.

The fact that GitHuman itself was built this way is the strongest argument for the approach. It works.

## Try It

```bash
npx githuman serve
```

Stage some changes, open the browser, and see your diff the way it deserves to be seen.

---

*GitHuman is open source under the MIT license. Built with Claude Code, reviewed by a human.*
